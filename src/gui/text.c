#include "hammer/gui.h"
#include "hammer/error.h"
#include "hammer/glsl.h"
#include "hammer/image.h"
#include "hammer/window.h"
#include <assert.h>
#include <cglm/mat4.h>
#include <cglm/cam.h>
#include <SDL2/SDL_image.h>

#define FONT_DIR "resources/fonts/"
#define TEXT_VBO_SIZE 1048576
#define FONT_ATLAS_LAYERS ((int)'~' - '!')
_Static_assert(FONT_ATLAS_LAYERS == 93);

void *gui_element_with_focus;

struct text_vert {
	GLfloat position[3];
	GLfloat dimensions[2];
	GLuint  color;
	GLubyte weight;
	GLubyte style;
	GLubyte character;
};

struct font_atlas {
	GLenum texture_format;
	GLuint texture_array;
	int    texture_width;
	int    texture_height;
	float  character_ratio;
};

/*
 * Returns a font_atlas constructed from merging all individual character
 * images in a font name subdirectory of hammer/resources/fonts. These images
 * are generated by hammer/scripts/generate-atlas.
 */
static struct font_atlas load_font_atlas(const char *fontname, GLenum texture);

/*
 * Global state of text renderer.
 */
struct {
	struct text_vert *buffer[FRAMES_IN_FLIGHT];
	size_t buffer_count[FRAMES_IN_FLIGHT];
	struct font_atlas regular_atlas;
	GLuint shader;
	GLuint vao;
	GLuint vbo[FRAMES_IN_FLIGHT];
	struct gui_text_renderer_uniforms {
		GLuint font_atlas_sampler;
		GLuint font_height;
		GLuint ortho;
	} uniforms;
} gui_text_renderer;

void
gui_text_init(void)
{
	gui_text_renderer.shader = compile_shader_program(
	                             "resources/shaders/gui_text.vs",
	                             "resources/shaders/gui_text.gs",
	                             "resources/shaders/gui_text.fs");
	if (gui_text_renderer.shader == 0)
		xpanic("Error creating GUI text shader");
	glUseProgram(gui_text_renderer.shader);

	gui_text_renderer.uniforms = (struct gui_text_renderer_uniforms) {
		.font_atlas_sampler = glGetUniformLocation(gui_text_renderer.shader, "font_atlas"),
		.font_height = glGetUniformLocation(gui_text_renderer.shader, "font_height"),
		.ortho = glGetUniformLocation(gui_text_renderer.shader, "ortho")
	};

	glGenVertexArrays(1, &gui_text_renderer.vao);
	glBindVertexArray(gui_text_renderer.vao);

	glEnableVertexAttribArray(0);
	glEnableVertexAttribArray(1);
	glEnableVertexAttribArray(2);
	glEnableVertexAttribArray(3);
	glEnableVertexAttribArray(4);
	glEnableVertexAttribArray(5);

	glGenBuffers(FRAMES_IN_FLIGHT, gui_text_renderer.vbo);
	GLbitfield flags = GL_MAP_WRITE_BIT |
	                   GL_MAP_PERSISTENT_BIT |
	                   GL_MAP_COHERENT_BIT;
	for (size_t i = 0; i < FRAMES_IN_FLIGHT; ++ i) {
		glBindBuffer(GL_ARRAY_BUFFER, gui_text_renderer.vbo[i]);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(struct text_vert), (void *)offsetof(struct text_vert,position));
		glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(struct text_vert), (void *)offsetof(struct text_vert,dimensions));
		glVertexAttribIPointer(5, 1, GL_UNSIGNED_INT, sizeof(struct text_vert), (void *)offsetof(struct text_vert,color));
		glVertexAttribIPointer(2, 1, GL_UNSIGNED_BYTE, sizeof(struct text_vert), (void *)offsetof(struct text_vert,weight));
		glVertexAttribIPointer(3, 1, GL_UNSIGNED_BYTE, sizeof(struct text_vert), (void *)offsetof(struct text_vert,style));
		glVertexAttribIPointer(4, 1, GL_UNSIGNED_BYTE, sizeof(struct text_vert), (void *)offsetof(struct text_vert,character));
		glBufferStorage(GL_ARRAY_BUFFER, TEXT_VBO_SIZE, 0, flags);
		gui_text_renderer.buffer[i] = glMapBufferRange(GL_ARRAY_BUFFER, 0,
		                                               TEXT_VBO_SIZE, flags);
		gui_text_renderer.buffer_count[i] = 0;
	}

	gui_text_renderer.regular_atlas = load_font_atlas("JetBrainsMono-Regular", GL_TEXTURE0);

	/* Constant uniform values */
	glUniform1i(gui_text_renderer.uniforms.font_atlas_sampler, 0);
	glUniform1f(gui_text_renderer.uniforms.font_height,
	            gui_text_renderer.regular_atlas.texture_height);
}

void
gui_text_deinit(void)
{
	glBindVertexArray(gui_text_renderer.vao);
	for (size_t i = 0; i < FRAMES_IN_FLIGHT; ++ i)
		glUnmapNamedBuffer(gui_text_renderer.vbo[i]);

	glDeleteTextures(1, &gui_text_renderer.regular_atlas.texture_array);
	glDeleteBuffers(FRAMES_IN_FLIGHT, gui_text_renderer.vbo);
	glDeleteVertexArrays(1, &gui_text_renderer.vao);
	glDeleteProgram(gui_text_renderer.shader);
}

void
gui_text_render(void)
{
	size_t f = window.current_frame % FRAMES_IN_FLIGHT;

	/* 0,0 top left */
	mat4 ortho_matrix;
	glm_ortho(0, window.width, window.height, 0, -1000, 1, ortho_matrix);

	if (gui_text_renderer.buffer_count[f]) {
		glUseProgram(gui_text_renderer.shader);
		glBindVertexArray(gui_text_renderer.vao);
		glUniformMatrix4fv(gui_text_renderer.uniforms.ortho,
		                   1, GL_FALSE, (float *)ortho_matrix);
		glBindBuffer(GL_ARRAY_BUFFER, gui_text_renderer.vbo[f]);
		glDrawArrays(GL_POINTS, 0, gui_text_renderer.buffer_count[f]);
		gui_text_renderer.buffer_count[f] = 0;
	}
}

void
gui_text(const char *text, size_t len, struct text_opts opts)
{
	size_t f = (window.current_frame + 1) % FRAMES_IN_FLIGHT;
	float char_width = opts.size * gui_text_renderer.regular_atlas.character_ratio;
	for (size_t i = 0; i < len; ++ i) {
		if (TEXT_VBO_SIZE <= gui_text_renderer.buffer_count[f] *
		                       sizeof(struct text_vert))
		{
			continue;
		}
		int c = (int)text[i] - '!';
		if (c < 0 || c >= FONT_ATLAS_LAYERS)
			continue;
		float x = opts.xoffset + char_width * i;
		float y = opts.yoffset;
		size_t vi = gui_text_renderer.buffer_count[f] ++;
		gui_text_renderer.buffer[f][vi] = (struct text_vert) {
			.position = {x, y, opts.zoffset},
			.dimensions = {char_width, opts.size},
			.color  = opts.color,
			.weight = opts.weight,
			.style  = opts.style,
			.character = c
		};
	}
}

void
gui_text_center(const char *text, size_t len, float width, struct text_opts opts)
{
	float ww = gui_char_width(opts.size);
	opts.xoffset += (width - len * ww) / 2;
	gui_text(text, len, opts);
}

float
gui_char_width(float font_size)
{
	return font_size * gui_text_renderer.regular_atlas.character_ratio;
}

static struct font_atlas
load_font_atlas(const char *fontname, GLenum texture)
{
	struct font_atlas atlas;
	glGenTextures(1, &atlas.texture_array);
	glActiveTexture(texture);
	glBindTexture(GL_TEXTURE_2D_ARRAY, atlas.texture_array);

	SDL_Surface *surface;
	for (int i = 0; i < FONT_ATLAS_LAYERS; ++ i) {
		char filename[64];
		snprintf(filename, 63, FONT_DIR "%s/%d.png", fontname, i+'!');
		surface = IMG_Load(filename);
		if (!surface) {
			errno = EINVAL; /* TODO: bad */
			xpanicva("Error loading font atlas image file %s: %s",
			         filename, SDL_GetError());
		}
		GLenum format;
		GLenum internalformat;
		switch (surface->format->BytesPerPixel) {
		case 4:
			format = GL_RGBA;
			internalformat = GL_RGBA8;
			break;
		case 3:
			format = GL_RGB;
			internalformat = GL_RGB8;
			break;
		case 2:
			format = GL_RG;
			internalformat = GL_RG8;
			break;
		case 1:
			format = GL_RED;
			internalformat = GL_R8;
			break;
		}

		/* Determine format from first image */
		if (i == 0) {
			atlas.texture_format = internalformat;
			glTextureStorage3D(atlas.texture_array,
			                   1, /* mipmaps */
			                   atlas.texture_format,
			                   surface->w, surface->h,
			                   FONT_ATLAS_LAYERS); /* layers */
			atlas.texture_width  = surface->w;
			atlas.texture_height = surface->h;
			atlas.character_ratio = atlas.texture_width /
			                        (float)atlas.texture_height;
		}
		assert(atlas.texture_format == internalformat);
		assert(atlas.texture_width  == surface->w);
		assert(atlas.texture_height == surface->h);

		glTextureSubImage3D(atlas.texture_array,
		                    0,    /* mipmap level */
		                    0, 0, i, /* x,y,z offsets */
		                    surface->w, surface->h, 1, /* w,h,layer */
		                    format,
		                    GL_UNSIGNED_BYTE,
		                    surface->pixels);

		SDL_FreeSurface(surface);
	}

	glTextureParameteri(atlas.texture_array, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTextureParameteri(atlas.texture_array, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTextureParameteri(atlas.texture_array, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTextureParameteri(atlas.texture_array, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	return atlas;
}
