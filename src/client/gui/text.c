#include "hammer/client/glsl.h"
#include "hammer/client/gui/text.h"
#include "hammer/client/window.h"
#include "hammer/error.h"
#include "hammer/image.h"
#include <assert.h>
#include <SDL2/SDL_image.h>

#define FONT_DIR "resources/fonts/"

/*
 * Returns a font_atlas constructed from merging all individual character
 * images in a font name subdirectory of hammer/resources/fonts. These images
 * are generated by hammer/scripts/generate-atlas.
 */
static struct gui_text_font
load_font_atlas(const char *fontname, GLenum texture);

void
gui_text_renderer_create(struct gui_text_renderer *renderer)
{
	renderer->shader = compile_shader_program(
	                     "resources/shaders/gui_text.vs",
	                     "resources/shaders/gui_text.gs",
	                     "resources/shaders/gui_text.fs");
	if (renderer->shader == 0)
		xpanic("Error creating GUI text shader");
	glUseProgram(renderer->shader);

	renderer->uniforms.font_sampler = glGetUniformLocation(renderer->shader, "font_sampler");
	renderer->uniforms.font_height = glGetUniformLocation(renderer->shader, "font_height");
	renderer->uniforms.ortho = glGetUniformLocation(renderer->shader, "ortho");

	glGenVertexArrays(1, &renderer->vao);
	glBindVertexArray(renderer->vao);

	glEnableVertexAttribArray(0);
	glEnableVertexAttribArray(1);
	glEnableVertexAttribArray(2);
	glEnableVertexAttribArray(3);
	glEnableVertexAttribArray(4);
	glEnableVertexAttribArray(5);

	renderer->font_regular = load_font_atlas("JetBrainsMono-Regular", GL_TEXTURE0);

	/* Constant uniform values */
	glUniform1i(renderer->uniforms.font_sampler, 0);
	glUniform1f(renderer->uniforms.font_height,
	            renderer->font_regular.texture_height);
}

void
gui_text_renderer_destroy(struct gui_text_renderer *renderer)
{
	glDeleteTextures(1, &renderer->font_regular.texture_array);
	glDeleteVertexArrays(1, &renderer->vao);
	glDeleteProgram(renderer->shader);
}

void
gui_text_frame_create(struct gui_text_renderer *renderer,
                      struct gui_text_frame    *frame)
{
	glBindVertexArray(renderer->vao);

	glGenBuffers(1, &frame->vbo);
	GLbitfield flags = GL_MAP_WRITE_BIT |
	                   GL_MAP_PERSISTENT_BIT |
	                   GL_MAP_COHERENT_BIT;
	glBindBuffer(GL_ARRAY_BUFFER, frame->vbo);
	const size_t VS = sizeof(struct gui_text_vert);
	const size_t offset[6] = {
		offsetof(struct gui_text_vert, position),
		offsetof(struct gui_text_vert, dimensions),
		offsetof(struct gui_text_vert, weight),
		offsetof(struct gui_text_vert, style),
		offsetof(struct gui_text_vert, character),
		offsetof(struct gui_text_vert, color)
	};
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, VS, (void *)offset[0]);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, VS, (void *)offset[1]);
	glVertexAttribIPointer(2, 1, GL_UNSIGNED_BYTE,  VS, (void *)offset[2]);
	glVertexAttribIPointer(3, 1, GL_UNSIGNED_BYTE,  VS, (void *)offset[3]);
	glVertexAttribIPointer(4, 1, GL_UNSIGNED_BYTE,  VS, (void *)offset[4]);
	glVertexAttribIPointer(5, 1, GL_UNSIGNED_INT,   VS, (void *)offset[5]);
	glBufferStorage(GL_ARRAY_BUFFER, GUI_TEXT_VBO_SIZE, 0, flags);
	frame->vb = glMapBufferRange(GL_ARRAY_BUFFER, 0, GUI_TEXT_VBO_SIZE, flags);
	frame->vb_vc = 0;
}

void
gui_text_frame_destroy(struct gui_text_frame    *frame)
{
	glUnmapNamedBuffer(frame->vbo);
	glDeleteBuffers(1, &frame->vbo);
}

void
gui_text_render(struct gui_text_renderer *renderer,
                struct gui_text_frame    *frame)
{
	if (frame->vb_vc == 0)
		return;

	glUseProgram(renderer->shader);
	glBindVertexArray(renderer->vao);
	glUniformMatrix4fv(renderer->uniforms.ortho, 1, GL_FALSE,
	                   (float *)window_ortho().raw);
	glBindBuffer(GL_ARRAY_BUFFER, frame->vbo);
	glDrawArrays(GL_POINTS, 0, frame->vb_vc);
	frame->vb_vc = 0;
}

void
gui_text_center(const char      *text,
                float            width,
                struct text_opts opts)
{
	size_t text_len = strlen(text);
	float ww = gui_char_width(opts.size);
	opts.xoffset += (width - text_len * ww) / 2;
	gui_text(text, opts);
}

static struct gui_text_font
load_font_atlas(const char *fontname, GLenum texture)
{
	struct gui_text_font atlas;
	glGenTextures(1, &atlas.texture_array);
	glActiveTexture(texture);
	glBindTexture(GL_TEXTURE_2D_ARRAY, atlas.texture_array);

	SDL_Surface *surface;
	for (int i = 0; i < GUI_FONT_ATLAS_LAYERS; ++ i) {
		char filename[64];
		snprintf(filename, 63, FONT_DIR "%s/%d.png", fontname, i+'!');
		surface = IMG_Load(filename);
		if (!surface) {
			errno = EINVAL; /* TODO: bad */
			xpanicva("Error loading font atlas image file %s: %s",
			         filename, SDL_GetError());
		}
		GLenum format;
		GLenum internalformat;
		switch (surface->format->BytesPerPixel) {
		case 4:
			format = GL_RGBA;
			internalformat = GL_RGBA8;
			break;
		case 3:
			format = GL_RGB;
			internalformat = GL_RGB8;
			break;
		case 2:
			format = GL_RG;
			internalformat = GL_RG8;
			break;
		default:
			format = GL_RED;
			internalformat = GL_R8;
			break;
		}

		/* Determine format from first image */
		if (i == 0) {
			atlas.texture_format = internalformat;
			glTextureStorage3D(atlas.texture_array,
			                   1, /* mipmaps */
			                   atlas.texture_format,
			                   surface->w, surface->h,
			                   GUI_FONT_ATLAS_LAYERS); /* layers */
			atlas.texture_width  = surface->w;
			atlas.texture_height = surface->h;
			atlas.character_ratio = atlas.texture_width /
			                        (float)atlas.texture_height;
		}
		assert(atlas.texture_format == internalformat);
		assert(atlas.texture_width  == surface->w);
		assert(atlas.texture_height == surface->h);

		glTextureSubImage3D(atlas.texture_array,
		                    0,    /* mipmap level */
		                    0, 0, i, /* x,y,z offsets */
		                    surface->w, surface->h, 1, /* w,h,layer */
		                    format,
		                    GL_UNSIGNED_BYTE,
		                    surface->pixels);

		SDL_FreeSurface(surface);
	}

	glTextureParameteri(atlas.texture_array, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTextureParameteri(atlas.texture_array, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTextureParameteri(atlas.texture_array, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTextureParameteri(atlas.texture_array, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	return atlas;
}
